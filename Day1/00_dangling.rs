// dangling.c 와 동일한 의미의 Rust 코드
// run 00_dangling.rs
fn main()
{
	let r : &i32;
	{
		let n = 10;
		r = &n;
	} // <== n 파괴

	println!("{}", r); // r이 가리키는 곳은 파괴되었음.
					   // 컴파일 에러!
					// 즉, 잘못된 메모리 사용을 컴파일 시간에 검출.
}

// C/C++ : 메모리의 잘못된 사용을 컴파일 시간, 실행시간 모두 검사 못함
//	       개발자 책임. 단, 아주 빠르다.  "undefined behavior" 가 있다.

// C#/Java : 메모리의 잘못된 사용을  실행시간 모두 검사 가능
// 			(사용자가 실수해도 가상머신이 검출, 예외 발생)
//			undefined behavior 가 거의 없다.
//			단, 느리다.

// Rust : 메모리의 잘못된 사용을 컴파일 시간에 확인.
//        => 컴파일만 되면 안전하다.
//				=> 아주 드물게 컴파일 되지만 실행시 오류 발생 가능.
//				=> 단, 미정의 동작이 아닌, 잘못된 코드.. (실행시간 오류 검출한것)
//		  => C/C++ 만큼 빠르다.
//        => 그런데, 컴파일 시간에 검사하게 하기 위해서는 반드시 지켜야 하는
//           규칙이 있고, 이 규칙이 어렵다 => 내일의 주제
//