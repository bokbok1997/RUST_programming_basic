// QA1.rs
#![allow(unused)]

struct Point 
{
	x : i32,
	y : i32,
}

fn main()
{
	let mut pt = Point{x:1, y:1};	

	/*
	// mutable reference 은 오직 한개만 만들수 있습니다.
	let r1 = &mut pt; // <== 대여 시작 ====================
	let r2 = &mut pt; // error

	r1.x = 10;		  // <== 반납      ===================
	*/

	let r1 = &mut pt.x;	// <==== x 대여 시작 ============
	let r2 = &mut pt.y; // ok.. 컴파일러는 값(메모리공간이) 다르다고 보장할수 있다

	*r1 = 10;			// <==== 반납 =================

	//-----------------------------
	let mut arr = [1,2];

	let r3 = &mut arr[0];	// <==   0 번째 요소 대여 시작 ============
	let r4 = &mut arr[1];	// error.
							// 컴파일러는 "단지 인덱스값 0, 1" 만으로
							// => 2개의 메모리 공간이 다르다느 보장할수 없다.
							// => [] 는 결국 함수(연산자 재정의)로 구현된것
							// => 구현은 다양할수 있다
							// => arr.split_at_mut() 메소드 사용하면 가능(중급)

	*r3 = 10;				// <== 반납

}