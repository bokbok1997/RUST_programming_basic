#![allow(unused)]

// slice method

fn main()
{
	let mut v = vec![1,3,5,7,9,2,4,6,8,10];
	
	println!("{:?}", v);

//	v.sort();	// v 의 모든 요소 정렬

//---------------------------------------------------------
//	let s = &v[2..8]; // v 의 일부분을 접근하는 slice(다른언어는 "view" 라고 부릅니다)
					  // 읽기 전용 slice

	let s = &mut v[2..8];	// R/W 가능한 slice
	s.sort();	// 일부분만 정렬
//---------------------------------------------------------

	// 위 주석 사이의 코드는 일반적으로 아래 처럼 사용합니다.
	// => sort(&mut self) 입니다.
	&mut v[2..8].sort();	// 정확한 코드
	&v[2..8].sort();		// ok
	v[2..8].sort();			// ok. 보통 이렇게 사용. 그래서 편리합니다
							// => 그런데 ??? 이게 왜 되나요 ??
							// => 문법적으로 어떤 원리
							// => struct 문법의 auto-ref 때문에 가능.

	v[2..8].sort();	// sort(v[2..8]) 의 의미지만 "auto-ref" 에의해서
				    // sort(&mut v[2..8])

	println!("{:?}", v);
}
