#![allow(unused)]

fn main()
{
	let n = 10;

	// #1. 레퍼런스 만들기
	let r1 : &i32 = &n;
	let r2        = &n;

	// #2. 레퍼런스로 값에 접근하기 => * 사용
//	let a1 : i32 = r1;  // error. r1 은 i32 가 아닌 reference
	let a2 : i32 = *r1; // ok.  *r1 은 r1이 가리키는 대상체 접근(C와 동일) 


	// 아래 코드에서 b1, b2 의 타입은 ?
	let b1 = r1;	// &i32
	let b2 = *r1;	// i32


	// #3. reference 로 메소드 호출
	// => 값 접근은 * 필요하지만, 메소드 호출은 * 필요 없음.
	println!("{}", n.pow(2));  // ok. n 자체가 i32 타입
	println!("{}", r1.pow(2)); // ok. r1 은 &i32 이지만 메소드 호출시 자동 defef 됩니다.
								// => "auto deref" 라는 문법

//	println!("{}", *r1.pow(2)); // error. 


	// #4. 아래 결과 예측해 보세요
	println!("{}", n);  	// 10
	println!("{}", *r1);	// 10. 대상체 출력
	println!("{}", r1);		// ok. *r1 이 필요하지만, 출력시는 자동으로 대상체 값 출력
							// => let ret : i32 = *r1; // 단 이경우는 반드시 *r1 필요

	println!("{:p}", r1);	// 이렇게 하면 r1이 가진값(즉, n의 주소)

	println!("{:p}", &n); 	// 이 코드는 "n의 주소" 가 아닌 "n의 reference"
							// 그런데, reference 를 {:p} 출력시 주소 나옴
						    // 따라서 n 의 주소 출력


	println!("{:p}", &r1); 	// r1 이 가리키는 대상체의 주소가 아니라
							// r1 자신의 주소
					
	// 주의 : 레퍼런스 사용시 
	// 1. 대상체 접근은 *r1 해야 합니다.
	// 2. 단 아래 2가지 경우는 예외
	// => 메소드호출 "r1.메소드()"          <=== Rust 문법
	// => 화면에 출력 "println!("{}", r1)" <=== println 의 구현원리

}